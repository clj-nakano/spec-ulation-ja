---

# Spec-ulation

- https://www.youtube.com/watch?v=oyLBGkS5ICk
- clj-nakano #3 2018/1/16
- 株式会社シグニファイア代表 中村研二 (github: k2n, twitter: @k2nakamura)

---

## 発表者について

- 93-00年 野村総合研究所、00-16年 米国スタートアップ数社で勤務
- 15年、200億円規模の米国証券バックオフィスシステムにClojureを適用
    - compojure-api, core.async, aleph, manifold, gloss, mysql, mongo db, docker, AWS

---

## 発表者について

- 16年、Clojure+Docker+Micro Services+AWSでビスポーク開発を提供する株式会社シグニファイアを設立
- 16年、たばこ卸売業向けEコマースとたばこ税申告システム
    - AWS Lambda, Incanter, compojure-api, clara-rules, reagent, postgresql, docker, rancher, AWS
- 17年、グローバル法律事務所紹介ネットワークシステムでLegalWeek Innovation Awardsを受賞
    - reagent, re-frame, compojure-api, elastic search, postgresql, docker, rancher, AWS

---

## Spec-ulation

- もう一度、このカンファレンスに来れるのは素晴らしい。古い友人、新しい人達。みんな嬉しそうに見える。とてもいいことだ。
- コミュニティが前向きであることの重要性は繰り返して述べる価値がある。新しいものを試したり、今までとはちがった方法を試す楽観的か、あるいはクレイジーな人がたくさんいる。また同じように楽観的/クレイジーな人の手助けもしてくれている。 
- この講演をspec-ulation（考察）と名付けた。実際はこれから怒りをぶちまけるのだが、それを覆い隠すためのタイトルだ。

---

## This is not a talk about spec

- Specについての講演やワークショップが本カンファレンス内でいくつか開催されているが、この講演はSpecそのものについての話ではないし、Specのチュートリアルでも、Specについての技術的な解説でもない。
- これは、Specが何のために作られたかについての話である。というのも、みなさんがSpecについて学んだり、Specでこれができる、あれができるという話を聞いて得た内容は、Specを構築するための基礎均しであったり、目立つ特徴についての話であり、これから述べる２つの点を意識してデザインされていることが明白かどうか確信が持てないからである。
- Specは、誰かが他の人に渡すことができるものであり、受け取った人が使えるものである。重要な点は、「使える」というのはポジティブな意味であり、従わなければいけないルールではない、ということである。Stuart Hallowayが、ドキュメントがなかったり不足しているコードをみて、どんなmapなのか、どんなキーを持つべきなのか困惑した経験についてかたっていたが、これはそれについての話である。
- もう一つの点は、最初の点と同様、ユーザーであるあなたが何か間違ったことをしているということではなく、サービスを共有する側の自分が、コードの振る舞いについて約束をするということである。ここでの意味は、将来に渡ってその約束したものを利用できないようにはしない、ということである。この点を今日は強調していきたい。

---

## Change

- Specは「変化」というより大きな問題の一部と言える。
- Specはこうしなさい、ああしなさいという指示を与えるものと見ることもできるが、実際は、後で変更できるかどうかについて表しているものなのだ。
- Specの大部分は物事を後で変更できるかどうかについてなのである。
- 今日、「変化」という言葉を何度も繰り返し使った会話をした。「変化」という単語はソフトウェア開発でおころ様々な事象をカバーしている。
- 答えを出さなければいけない疑問は、それが「物事」なのか、そしてそれがもし「物事」であるならば、ソフトウェアのライフサイクルの中で、我々が必要としているものであるのか、という点である。

---

## 'Change'

- 今日の話の中でまだ出てきてなかったのがびっくりだが、お約束の辞書の定義だ。
- 誰もが私が講演をする前に明らかに当たり前だったり、間違ったことを言わないようにWikipediaを見ておけというが、私は辞書に当たることにしている。
- 「変化」の辞書における定義は再帰的である。定義に使われている2つの言葉の片方に、"change"が含まれているからだ。
- 語源は、交換、物々交換である。ドイツ風ボードゲームで遊んだことのある人は何人いますか？いないの？牛を小麦に交換して、小麦を材木に、材木を石に、という具合で、おわかりのように中世ではこの方法によって成功を収めていたわけである。
- これは同一の場所で起こる変形、変質ではない。ものを交換しているのである。
- 相手の許可や協力なしに交換しようとしたら？ 人からものを盗ったことになる。すくなくとも良いことではない。ただ現実問題として、自分のほうで物事が変わっていくことがある。
- 依存関係にまつわる問題を調べたことのある人はいる？それを楽しんだ人はどのくらい？いないよね！
- 何ができるだろう？ソフトウェアをイミュータブルにすることはできない。どうやって前に進むことができるだろう？「変化」の代わりになる言葉を探したいのだが、どうやって、利用者が我慢できる範囲でソフトウェアをより良いものに、明日には違うものにしていくことができるのだろう？少なくとも我々が改善したときに、どうやったら正しく変更できるかみんなが理解できるようにすることができるだろう？

---

## Dependencies

- どうやって変更するか知っているよね？我々はmavenやmavenを駆動するものを使ってライブラリなどの成果物を取得している。自分はあるバージョンのライブラリA,B,Cを使いたい。しかしライブラリは、自分が動作するためにはこのバージョンのライブラリXが必要で、ライブラリYも必要である。ライブラリBは違うバージョンのライブラリYが必要で、ライブラリCははライブラリZを必要とする。ここでライブラリYのバージョン2.1と2.4の間に矛盾が生じる。スライドが見えるかどうかわかりませんが、矛盾があると想像してください。Mavenは通常、新しいバージョンである2.4を自動的に選択して動作するようにするルールがある。この木構造は、直接・間接の依存性を表しており、これがアプリケーションを動作させるのに必要な情報である。正しい？ 誘導された質問にYesと答えるような間抜けではないよね？

--- 

## But...

- まず、アーティファクト(訳注：Jarなど）はこのレベルでは使われていない。ライブラリは他のライブラリをこのレベルでは使っていない。アーティファクトは実際のところ何もしていない。単なるパッケージにすぎない。アーティファクトは他のアーティファクトを使っていない。様々な理由でアーティファクトのリストを持っているだけだ。この点については後ほど触れる。
- もう一つの点は、少なくともClojureには、このインフラストラクチャを利用する他の殆どの言語も、アーティファクトについてのコードは存在しない、ということである。 

---

## Dependencies Redux

- それでは、アプリケーションが実際に必要としているものはなんだろうか？
- この問題をもう一度見てみる。今回は少し拡張してある。今回はアーティファクトの中身もみていく。
- 何が見える？私があなたにあげるJarの中には、Clojureであれば名前空間, Javaであればパッケージsがある。本質的に両者は同じものである。
- 実際、我々のアプリケーションも同様に分解することができる。アプリの中には自分で書いた名前空間がいくつかあって、それが、他の名前空間を参照する。
- app.ralph 名前空間はA.ricky 名前空間をrequireし、app.ralph 名前空間はc.fredもrequireし、app.trixieは、B.lucyをrequireする。これらはコードの中で見える。これはいいことである。
- A.rickeyはY.barneyをrequireし...誰か他の名前があったんだけど、今朝Paulaが違うテレビ番組から名前を拾ってきたから... Barney, Willmaなど。視力がいい人ならこれが真実だとわかるよね？実際の名前空間が他の名前空間やパッケージをインポートしていて、それが実際にコードの中にある。実際のコネクションだ。いいよね？
- 視力がいい人なら、この図を見るだけでわかることがあるよね？我々のアプリケーションはライブラリX、Yは必要としているが、Zは必要ない。EthelだけがZを使っていて、アプリはEthelを使っていない。

---

## But...

- 実際のところ、これは前と同じことだ。名前空間はコードじゃない。何もしていない。requireは影響を及ぼす働きがあるからrequireを呼べば副作用は起こるけど、それは今おいておくとすれば、名前空間の宣言自体は何も達成していない。
- コードの中で依存関係が見えるという点は好ましいけれど、ここには別のイライラさせる問題があるよね。どうやってある名前空間がどのアーティファクトに含まれているのかわかるのだろう？どのjarに含まれているのか？どのJarにFredが含まれているか教えてくれるような人はいない。これが問題だ。

---

## Dependency Truth (code)

- 真実はどこか、真実を見つけるには良い視力を持っていなければならない。
- 中をさらに開けて、Ralphの中を見てみよう。Ralphは関数を持っている。関数fooがapp.ralphの中にある。
- ここに名前空間の美点がある。新しい名前を考えつくのがめんどくさくなったので、全ての名前空間の中の関数には同じfoo, barと名付けたが、衝突することはない。素晴らしい！
- ralph.fooはrickey.fooを呼び、rickey.fooはbarney.fooを呼び、rickey.barはfred.barを呼んでいる。以下同様。
- これが実際に呼ばれているコードで、実際の依存関係である。そして目で見ることもできる。
- ただ、紫色の凡例はみることができない。ralph.fooは何をrickey.fooに渡すのか？時間の経過とともに変わるかもしれない。何がrickey.fooからralph.fooに返されるのか？これも見ることができないし、時間とともに変わる可能性がある。非常に微妙な違いとなる。特にmapが返されるときには。
- 他に分かることは？ライブラリXは不要、ということだ。ralph.fooはricky.fooを呼んでいるが、barは呼んでいない。rickey.barだけがライブラリXを必要としている。だから、これは既にそんなに上手くいっていない。依存関係の木構造は、実際に必要としているものを表していない。
- 図の一番下で起こっていることは、あまり詳細には触れないが、内部呼び出しもあるという点である。ライブラリYの内側でbarney.barはbetty.fooを呼び出している。この２つの関数はマッチしていなければならないが、外部からそれを木構造を通して知ることができない。
- これが、ライブラリ全体を取り込むアプローチの「利点」である。必要な分より遥かに多くのコードを取り込まなければいけないが、マッチしなければいけないものを取り込むことができる。












　
