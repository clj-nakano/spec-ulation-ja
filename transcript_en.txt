hi every human yeah
once again it's fantastic to come to the
cons and see everybody old friends and
all the new faces and everybody being so
happy that's really great I think you
know it's just so important to revisit
the fact that the community is a
positive one that's you know full of
optimistic people or crazy people who
are like willing to try this new stuff
and and do things in a way that that's
different and to help out other people
who are similarly optimistic or crazy so
this talk is called speculation and
that's just a way of covering the fact
that it's a rant
so I think we have a few talks about
spec and there was a spec workshop and
so this is not a talk about spec it's
not a tutorial about spec it's not about
the tech of spec sort of in any way but
it is very much a talk about what spec
is about because I'm not sure when you
look at spec and what especially when
you hear our talk and you see you can do
this and you know it's a floor wax it's
dessert topping that it's evident
necessarily that particularly that some
of the design decisions are pointed at
these these two things which seem to not
say very much at all one is that spec is
about being able to give something to
someone so that they can use it and the
important thing about that that that
word use is that it's sort of like a
positive thing here's something you can
use as opposed to like here's some rules
that you have to follow so we want to be
able to give people things that they can
use and you know Stu talked about
getting you know a piece of code that
had no documentation or insufficient
documentation and wondering you know
what what should these Maps be what are
the keys and things like that so it's
hard to use that without more of a
description so it's about that but the
other side of it and again this is not
about you the user doing something wrong
it's about me the provider saying I'm
going to make a commitment this is the
way this thing works and in particular
the commitment means and I'm not going
to take that away later so I want to
emphasize that today and that spec is
designed around that and it's sort of
part of a bigger problem which is change
it's interesting to look at spec and say
spec is about doing this this way or
doing that that way or providing these
things but spec is really about being
able to change later a lot of what spec
is is oriented towards changing things
later but it's an important question
because I had a conversation just two
a where the word change was used a ton
of times we use the word change to sort
of cover a lot of things that happen in
software development and one question we
need to answer is is is the thing and if
it's a thing is it a thing that we want
in our software development lives so of
course you know I think this happened
yet today on surprise but here we go
the mandatory definition of a word I was
very surprised by this like everybody
says analyzed before I do my talking go
to Wikipedia to make sure I don't say
something you know obvious or obviously
wrong so I go to the dictionary and so
the definition for change is sort of
circular and that one of these two words
has the word change in it as well but
the origins of the word we're actually
exchanged it was about barter right you
can turn a cow into wheat how people
play euro games oh well you know you can
turn cows into wheat and wheat into wood
and wood into stone apparently these
things lead to great success in the
Middle Ages so that's not transmutation
right that's not like stuff changing in
places look exchanging stuff and when
you think about that way you can say
well what does it mean to just change
something without somebody's permission
or cooperation or participation right
one one way to say is that you just took
something from them but at least it's
not something that's nice but I think
that in practice we have things changed
on us and we experienced this last line
by how many people have ever chased down
dependency problems how many people
enjoyed that
okay so what are we going to do right
it's not like software should be
immutable that's not that's not the
thing but how do we move it forward
right so I'd like to find some different
words and change in this particular case
how do we make it better and different
tomorrow in a way that you know our
consumers can tolerate or at least can
we consider that when we when we make it
better so we all know how we do change
right we use maven or something that
drives maven and we have artifacts which
are libraries and the library and our
application says I want to use these
libraries a B and C and these are the
versions I want and then library a says
oh but I need library X to work and this
is the version I want and I need library
Y to work and this is a version I want
library B says I also need library Y and
I want a different version and library C
says I want library Z so we have a
little conflict here 2.1 and 2.4 i don't
know if you can read that you can
imagine what it says something that's in
conflict and the Maven has some rules
that automatically make this work
usually it will pick the later think 2.4
it is and this tree right the our
immediate dependencies and the
transitive dependencies are the things
we need to have our program run right
you all know better than to answer yes
no rhetorical questions with it yes no
no right so the first thing is that
artifacts don't use anything right the
library doesn't use a library at that
level right because artifacts are not
doing anything right they're just
so they don't use the other artifacts
they have these lists of them for
various reasons we'll talk about the
other thing is there's nothing in the
code at least in closure and I think in
most languages that use this
infrastructure there's nothing in the
code about these artifacts these are the
two things to know so what does your
application actually need and so we'll
look at this problem again and we've
expanded it a little bit so we look
inside each of those artifacts what do
we see if there are closure artifacts we
see namespaces right I give you this jar
it's got a bunch of namespaces in it
we're at Java code there would be
packages in there by the same kind of
thing namespaces packages so there's a
bunch of them and in fact our app is
decomposed similarly right our app
starts with a couple of namespaces that
we wrote in our application space now
those namespaces do say requires right
so my app Ralph's namespace requires a
Riki namespace and my app Ralph's name
space requires see Fred namespace and
App Trixie requires be Lucy and then and
that's in code that's nice so we can see
it in our program at least and then we
go down and we say a Ricky needs why
Barney somebody else had some names oh
this morning Paula did these are
different TV shows apparently so we have
Barney and Wilma and for anybody who has
good eyesight so this is the truth right
this is the actual namespace requiring
namespace or importing package right and
now this is in code and these are the
actual connections between the things
right
well what with anybody's good site I say
what can you tell about this right now
already about our app needing XY and Z
we don't need Z right
only Ethel uses Z and the app doesn't
use Ethel so it's actually the same
thing right name spaces are not code
they don't do anything right there
requires well obviously name spaces
could be effective also you could
require something for a side effect but
if we set that aside the namespace
declaration that says require is not
actually trying to accomplish anything
itself so they don't really use that we
like the fact that we can see this in
the code but we have this other niggling
I would hope niggling problem with this
which is that how do we know which
namespaces are in which artifacts are in
which jars yeah I don't know somebody
tells us right we have and we meet
somewhere else treat you like did you
try this jar man it's got Fred in it
I'm loving it no really there's not a
place right where we keep this so that's
a problem so what's the truth the truth
is you need better and better eyesight
to solve this problem so we open it up a
little bit more and we look inside Ralph
and we see that Ralph actually has
functions in it there's a function foo
inside our app in our Ralph's namespace
and we also see the beauty of namespaces
here because I just got tired of making
up new names and I didn't want to get
into TV shows so like every namespace as
a foo and a bar function but they're
conflict free because namespaces are
awesome right so Ralph foo calls Riki
foo and Riki foo calls Barney foo and
Riki bar calls Fred bar right and so on
and so forth these are the actual calls
that are made these are the actual
dependencies right code that needs to
run needs other code in order to work
that's the truth so we can also see that
right because those calls are evident
but one thing that's not evident there's
no purple lines but in the in the legend
there's purple which is that we depend
for instance we see that Ralph foo
depends on Ricky foo the function to
exist but there are other details about
that call right
what does Ralph ooh pastor Ricky foo
well maybe that changes over time I
don't really know what is Ricky foo
returned to Ralph foo and all callers
well maybe maybe that changes over time
that stuff is invisible right because
maybe you start consuming it tomorrow or
and it's very subtle what you use of the
return value especially when we start
returning maps and then for people with
really excellent eyesight what else do
we discover now from this we don't need
X right Ralph
foo calls
a Ricky foo it never calls Ricky bar and
Ricky bar was the only thing that needed
X so this is already like not great
right it's not our dependency tree is
not really reflecting our actual or
actual needs another thing that's going
on here in the bottom and I'm not going
to talk too much about it except to say
that there are also internal calls right
so inside library why Barney bar calls
Betty foo that needs to match but nobody
can see that in the direct tree
necessarily but we do want to make sure
that those things match and that's one
of the advantages of pulling in an
entire library is that you know the
stuff will match even if you're getting
way more stuff than you need whatever
stuff you need you know should match so
this is not great but you know
supposedly this is not a problem one of
the reasons why is because we have
semantic versioning and in the semantic
versioning spec which has been versioned
by the way and and I had to walk through
like a ton of dips to like see what had
changed over time mostly I guess because
I don't know how to use git but there
wasn't like a summary of what's
different between the two things but
it's in version and of course when you
start versioning your versioning but
supposedly right we have these rules we
have major versions and if a major
version doesn't transition we have this
implication that it should still work is
this what happens in practice has
anybody ever bumped to Depp in order to
make a leaf a library visible to an
application yeah everybody at some point
has done this yes this is the answer yes
we all do this it's okay yes no this is
what happened this isn't what isn't what
happens we're bumping versions all the
time right something we use
is better somehow in a way that our code
does not care that doesn't change our
code at all we get our new DEP changes
our name change the name of the thing
that clocks to us and so on and so on
and so forth this is a lie
all right this cascading version bumping
happens all the time we're just trying
to communicate through this palm tree
through this thing and I will call this
a level violation we're going to talk
about levels now so what is actually
happening well there's a few different
there's a stratification of problems
here right if we start at the bottom
right this call truth we know that
functions call other functions by name
what is happening at the next and and
that's you know it's clear in fact if
you just treated the namespace
declarations as aliasing when I forget
about code loading if they were just
aliasing they tell you enough they would
tell an analysis tool enough to know
when you said foo over here you were
talking about Ricky's foo and therefore
you you need to know about what Ricky's
foo the the actual requires is just
creating an execution context in which
that call will work that the code for
Ricky's foo will be available and that
requires will do that it will also make
a whole bunch of other code you don't
call available but we know it will cover
your need so we put that in our code so
it creates a context if we go up another
level to the artifacts the same thing is
happening those palms are saying I need
these other libraries they create a
context in which those requires are
going to succeed that this this thing
requires this other library this other
namespace that will be there because
somebody on the street told us that if I
use this jar Fred will be there and
therefore it will work but the problem
that's really broken is that this last
level the person on the street told us
to do this is pure magic right there's
nothing in code about this thing and
that it's going to come back later
so we now understand the levels this
functions calling functions name space
requires artifacts so why do we do this
what happen you know like what is this
doing for us I mean I don't think it's
you know just inherently terrible but
what is what is happening can we
disentangle what we're trying to say so
why do we put things in our depths or
pom or a project file at all and one is
that we need the codes when we're
working right we're writing our app
we're not writing this library it used
to be before we had depths that we would
like download jars and we would make
clasp as ourselves and say use this
classpath it actually wasn't worse than
this to be honest with you because
there's something about a list that you
made and you know what's in it and you
know what's not in it and you know it
says that's somewhat well it's certainly
more tangible but somewhat more reliable
than this next point which is that
what's also nice is we conveniently say
we needed
ABC and the fact that XY and Z were
needed was just solve for us maven will
NAB through the transitive dependencies
and pull everything else in so there's
an ease factor to point to here right
the other thing we do with this these
depths or the pom is that we turn around
or our build turns around and propagates
them into our artifacts so that maven
can do this with our stuff right can
continue to nav down and let somebody
who uses us and in particular when I'm
talking about us today I'm mostly
talking about when we write libraries
right when you have the consuming app
it's somewhat different and I'll talk
about that later but in particular when
we're writing libraries so we're writing
a B or C right we use X we need that in
our palm so someone who uses us gets X
in addition to us so the whole YZ thing
and stuff works so that's why we do it I
think one of the things people imagine
happens from putting in this in this
project file is we give some integrity
promise we make some integrity promise
about we've tested our library against
this thing
I do not care because the chances of me
running against the thing you test it
against are slim in the end we'll talk
about that later so I think that's a non
benefit you imagine it but it's not true
but again the problem is that this is
coarse-grained these things are don't
tell us what's actually happening and
they just create a context so what I
would like to talk about is how we talk
about change because you know I
mentioned things change and then we're
going to change versions or get new new
versions but I want to disentangle this
and I think that you can boil down all
change into this kind of language right
which is if I'm making a library I may
make requirements of the users of my
stuff right so what do I require if I'm
writing a function what I require are
the arguments you have to pass me
arguments if I'm a namespace what do I
require just names right a namespace is
sort of like a lookup your give me this
name I gave you this bar or the function
the thing in it go out the level again
what do artifacts require if I give you
a jar what are you going to do you're
similarly going to look for stuff in
there right with either a name or a path
you're going to find the actual class
file or clj file given some name right
so there's a sense in which namespaces
and artifacts are just functions of
names to stuff okay a namespace is a
function of a name to a bar or function
artifacts as a function of a name to a
namespace for package right then you can
flip it around and you can say what does
the library provide a function provides
its return right if you gave me what I
required I will provide to you this
result
and of course I would like to broaden
this discussion to include services and
procedures and things like that so if
your thing is affect 'full right one of
the things you provide is that effect
right if you call this thing with these
arguments the thing will be in the
database or I will send an email for you
or some other some other thing what does
a namespace provide it's just the lookup
but you give it a name it gives you the
VAR function what does an artefact
provide you gave it the name it's going
to provide you with the class files the
packages this kind of stuff so that's
how we exchange things so what I will
say is that you can now look at the
kinds categorically the kinds of changes
you would make in these ways right the
first is this idea of growing your
software your software is going to do
more the first thing is just a chr?tien
right what happens when you recruit you
say I'm going to provide you more you
were giving me seven before and I gave
you back 42 and now I'm going to give
you back 42 and some we write more stuff
so this not a lightweight use of this
word provide I mean very specifically we
need to say the words provide and
require so we're going to provide more
that's straight accretion the other
thing is relaxation right it used to be
you give me two wheat and a donkey and
I'll give you some steel and now I don't
need the donkey just going to be wheat
and I'll give you steel so I require
less right that's a relaxation on my
part right and there's a nice sort of
zen-like thing of saying you know the
less you need the the more you're
growing right it is it well whatever
I will push them not that like
touchy-feely and the others fixation and
this is another cool thing as I looked
up fixation it actually means to fix
things it doesn't mean to be paranoid so
then the final thing is just fixing
stuff which doesn't impact what you
provide or require it just means you're
now doing it correctly or maybe faster
or maybe with fewer requirements you
know fewer dependencies or something
something else but whatever it doesn't
impact what you provide or require ok
because again this blanket concept of
change it also is used casually in
conversation to talk about these things
which is breaking your software how do
you break your software you require more
oh that to eat and a donkey it's not
enough I want gold too and a ruby and
then you'll have steel right and you
know it's sort of evident I mean we use
bigger sentences to mean I broke you and
you know it's incompatible or something
like that but we should be using these
small things I just require more if you
require more than somebody who's giving
you less now is not going to get what
they want it's not going to work for
them it's broken
alright the flip side is you're
providing less well I was giving you
steel and now I'm going to give you tin
and good luck with your building so
you're providing less of returning less
than what you promised previously the
other sort of categoric you know why are
you doing this is just just changing
like you know we were calling that you
know trade and now we'd like trade to
mean like something completely different
so we're just going to use it for
something else and so if you were
calling trade you know it's like the
classic thing if you have well
homophones are or or something straight
out like draw write drawing pictures we
used to draw pictures for you and now we
draw guns for you
just the semantics are shot this
complete do-over so so the thing here is
that change is not a thing we shouldn't
really be saying I changed it because
you're telling me nothing when you say
that you tell me nothing because I just
described - this is great
I like this I'm happy to give you less I
like the new gold you're giving me
awesome awesome sauce here I'm really
angry at you right this is not good so
calling a change it's just not useful we
need to talk about one of two things is
either it grew or broke right there's
growth and there's breakage so there's
so one of the things that spec is
designed to do is to help us understand
and maybe even programmatically detect
when we've accidentally broken something
when we just intended to grow it and
make an argument for growing it in a
minute but but that's an important part
so that's why spec uses set logic for
maps and uses reg X's for sequential
syntax is because there there's already
logic for determining growth like
compatibility of those two things right
there's already math for that stuff so
it's not just going to be this I promise
you kind of use car dealer thing we can
we can you know we can run a program and
maybe determine this we don't have those
programs yet for a spec but spec is
designed to support them being written
so that helps us in the small as long as
we don't do something like try to
version specs version 2.00 the spec says
you need to give me gold now don't do
that
so what about changing the large well
the key thing here I would say is that
we need to start recognizing when things
are collections because there's only two
rules for collections right if something
is just a collection including an index
collection right you give me the name I
give you a thing but that's still a
collection it's just a index keed
collection right there's only two
operations
there's adding stuff to the collection
or removing stuff from the collection
adding stuff is growth period it's just
easy it's just accretion and removing
stuff is always breakage always removing
is breakage from a collection but the
important thing is when you look at
software you need to see these
collections because the other problem we
have all the time is we we keep
conflating changes at different levels
and the versioning system encourages
that right a namespace is just a
collection of VARs right artifacts are
just collections of namespaces or
packages we need to see that spec uses
sets for maps it doesn't let you say
what the keys mean for this reason it's
the same thing maps are collections of
keys they're not the stuff inside the
keys right if I put on a hat it doesn't
change what my family I would still
remember my family my family contain
these people before it contains the same
people later
I didn't version my family when I put on
a hat but we do this all the time all
the time we don't see this so you have
to recognize collections is really all
the interesting stuff happens at the
leaves and everything else is collection
with these two rules adding stuff fine
taking stuff away it breaking alright
now we get really ranty
semantic versioning I looked this up in
the dictionary and it didn't it wasn't
there right because because like what if
we had dictionary version right this
sort of a fundamental problem with this
idea of semantic versioning which is
like things mean what they mean until
they don't mean what they mean this is
helping me how I don't really see it so
let's dig into the semantics promised by
semantic versioning if you change the
patch part you don't care as a consumer
if you change the minor version you also
don't care but you just don't care these
things mean that they have this this
they have this great semantics for is
more than three that's it
you know I'm glad there's like a you
know a manifesto about this
but what about the major component what
does it mean it means you're screwed
right that's the semantics of the major
component it's terrible it's an absolute
catastrophe right it does because it
doesn't tell you in what way right what
it really says is you might be screwed
right so if somebody says you're screwed
you're like oh that's that's terrible
uh if somebody says you're Mike you're
screwed you're like it's worse it's
clearly worse right and why why is that
it's because this level thing it didn't
occur to this people who did this right
smash all the levels together any change
anywhere of anything that might be any
of the things we just like carefully
pulled apart and said you are requiring
more you're providing less this this is
big ugly thing where anything could have
happened and we're just telling you
watch out watch out and I don't think
that's useful right I think you know Stu
said it before trying to steal my
thunder you might as well just change
the name my going to 2.0 is not helping
anybody yeah just change the name I mean
what does it mean it's not it's just
completely not meaningful to do this to
somebody it just isn't it's just like
we're rule now playing a different game
and it's called the same name you know
have a seat you don't know how it's
played you thought you did I I predict
you're going to lose
and I think the thing is that you're
like well is that bad and then I'm not
changing it that's a new thing yeah
that's exactly right it's a new thing so
this raises the question of like which
name do you change because we just saw
this smashing together up into the
version of the artifact is probably not
good right so if I'm going to say to you
change the name I need to be able to
answer this question what name should I
change should I call the whole thing if
I'm if I'm requiring more in one of my
functions should I change the artifact
name to you know new game and now it's
the same thing right you're going to go
look at the levels for providing
requiring so are you requiring more
arguments or more from the arguments or
providing less in your return we
recognize these things as breakage
before essentially we're going to be
able to say this speck is incompatible
the speck for your revised function is
incompatible and if it is I want to see
a new function right and enclosure you
have two ways to do that you can stay in
the same namespace and you can have foo
- right or maybe you made a systemic
kind of change it's looks like we've
been passing around this thing and now I
realize that everywhere in our API we
should be passing around two things well
just make API - you know namespace you
can keep all the inner functions the
same which is fine I mean I know like
thinking of a good name is hard right
but namespaces mean you can glom some
different thing on the front and have
good name you know new place different
you know good name you don't have to you
know go on and on but in practice I
wouldn't either be afraid of foo -
because it's not it just doesn't happen
that often you know it just it really
just doesn't and and one of the things
that's really great about this this is
to remember that the namespace is part
of the name it there's really nothing
called for
to enclosure except like a local
variable everything else has a big hairy
name that includes the name space
beforehand we're always dealing
enclosure with these nice hopefully
globally unique names and spec liens on
that and you can lean on that to make
these kinds of changes the other thing
we have is our the aliases which help
again right because I could take some
code that used you know game one
namespace and called game 1 foo and now
what's called game 2 foo and it can just
say G foo everywhere in the code and
just change the NS declaration to say
you know require game 2 as G now if I
just did that and walked away from the
code it would break but I'm when I'm
doing that I'm saying well I'm moving to
the new thing I should read the new
specs read the docs I know some of the
names of berm reused but I'm in charge
right when do I need to do that when I
feel like playing the new game if I want
to continue to play the old game which
maybe I'm decent at I'm going to do that
I got a lot of week to get rid of all
right so what about if you want to get
rid of a fun I mean just I hate this
function I hate it I hate it I hate that
people call it I just want to add on my
life there's no functions like this
enclosure
so the way to do that what have you
changed right if you want to get rid of
a function you didn't change the
function really because it's like God
what did you change you change the
collection the collection no longer has
the the thing that was in it so where
are functions there in namespaces so the
namespace that collection level has
changed so you need to pick a new
namespace and again a major refactoring
might be a way to do this we've
deprecated a whole bunch of functions
blah blah blah we're going to move to
library 2 and really the biggest change
there is not that any of the functions
are different it's that half of them are
missing right we just don't want to have
them anymore so we have a new namespace
game - namespace and we just took out a
bunch of stuff and that's really what's
different about it so this is the way to
do that alright moving up another level
what about at the artifact level so what
if I want to get rid of these this
namespace I hate this namespace people
are still using this namespace I gave
them a better namespace you know three
years ago they should be using that I'm
tired of these people I'm going to take
this away from them I just really want
to do this what should i do well then
you know again because of the levels
thing we're getting rid of something in
the collection the collection is the
artifact and you would think by applying
this logic that you should just change
the artifact ID and you could you
definitely could the first counter
argument I would or objection I would
expect here is that's what the major
version is for you know that's what it
isn't right unless they're going to have
semantic versioning 3.0 which completely
changes what this means for everybody
who uses it and breaks all uses of it
and all presumptions about it forever
for everyone which they're not going to
do because in fact they don't believe in
semantic versioning you couldn't you
couldn't version semantic versioning
into supporting this change and that
shows that it's broken right semantic
versioning can't support this change you
can't have semantic versioning 3 oh I'll
do this without breaking everybody in it
in an unfixable way so unfortunately
they already decided what this means
which is and this is a quote from the
spec any backwards incompatible changes
across all the levels we can't suddenly
make it
mean only additions or removals only
removals of namespaces or packages would
cause this to move so it's got to
brought a semantics so that's not it the
problem we have here is that magic I
talked about earlier right if I just say
this is game 2 library right inside it
it's got you know turn one namespace but
game one library also has turned one
namespace and where's the mapping from
artifacts to namespaces I don't know the
guy in the street he's not there today
right it's nowhere there's not a place
for this so we can have these clashes
how many people have ever had a clash
where two jars they included had the
same package in them
woohoo how many people enjoyed that
right so this can happen in like there's
really nothing there the thing that it
solves this for us when we made this
change at the namespace level was the
fact that that implicitly gave us a new
scope it really actually renamed
everything in that thing if I still had
foo and bar I have game 2 foo and bar
they're not in conflict with game 1 foo
and bar I'm sort of ok if I do this up
at this level I'm not ok because it's
actually not an implicit change some of
the ways to deal with this would be
actually renaming your namespaces to
match this change because usually your
namespaces have some relationship to the
artifact name it's some the library name
is like in both I'm actually sure if
that's the right answer to this but I
would like to fix this ok so this just
seems like a lot of work right it
doesn't this make you reluctant to
remove things this is a rhetorical
question the right answer is yes it does
it makes me reluctant to move things
remove things and it should this like
yeah why should you get so uptight about
somebody calling the function that you
don't like anymore so what
like really what is more important okay
so here's the the root of the rant
breaking changes are broken that it's
just a terrible idea
don't do it don't do it don't try to
figure out the right way to do it don't
get together on the internet and say oh
we've all agreed you know major version
makes this possible woohoo it's a bad
thing you don't want to do it don't
figure out the best way to do it this
method of renaming turns breakage into
accretion right we still accomplish the
same thing right we got rid of that
pesky function because we have a new
name space that doesn't include it right
we you know we we clarified these
arguments so we we really need new stuff
to do this new job well we wrote a new
function to do that and it sits
alongside the other word this is
gigantic right because this coexistence
means people can just freely proceed
otherwise they have to be paranoid all
the time because how many people have
ever encountered a breaking change that
didn't move the major version and how
much fun was that it doesn't matter the
version it doesn't matter what matters
is that you did this it doesn't matter
how you covered it or didn't cover it or
what you said or how you excused it or
whatever it's just not good right so we
like this they can coexist we want to
turn breakage into accretion so it's may
even broken right this is what we do
with maven not really right we're doing
this to ourselves right maven is
actually quite interesting
first of all maven doesn't let you
change artifacts in it doesn't let you
do this right and may even never breaks
and maven is not versioned
is there maven version you know maven
central version 1,600,000 and 17 is
there right there isn't how could this
work how could how could this be all
these people changing all the stuff all
the time and maven never breaks it never
breaks because it actually
it doesn't voices that's for losers I'm
not doing versions maven central is a
big name you can rely on go to maven
central and you can find everything you
ever found in there forever and ever and
ever
that's the idea of maven central right
you don't say I'm going to use maven
central you know 5060 to I mean the
number would be astronomical right and
like oh no I use maven this and then
we'll have maven versioning versioning
maven central versioning we don't do
that and yet it works right it's where
it's like crazy we've all presumed what
this name maven central means we all
share it and we also all share an
understanding and actually sort of a
peaceful feeling that it will continue
to mean what it always meant forever and
ever and ever
how could this work how could it work
it's very straightforward
it's an accreting collection of
immutable things as functional
parameters we should be like duh of
course this works this is what we do in
the small everyday and at the very top
end of the ecosystem this is how it
works also so at the bottom it works
like this and at the top it works like
this so I'll just advise you right now
not to look up rotten sandwich on the
Internet
because it's it's it's quite unpleasant
but you can imagine this beautiful
sandwich right at the bottom we have our
functional program and we know we're
doing we we have all this assignment
conversation say with some we're talking
about you know talking to Java people
about using closure and I think I do
think it remains one of the biggest
challenges you have and trying to
evangelize closure is that you
eventually end up in a point where
you're trying to say to somebody you
know closure solves the problem that you
don't know you have and that problem is
like this intense anxiety and pressure
you feel dealing with mutability on an
ongoing basis and until you've
experienced that you know lifting and
closure is not the only language that
can do this for you but until you feel
that lifting you don't really know what
you were suffering from before it's like
if someone's standing on your foot every
day you'd be like you know you wouldn't
even know and then they get off you're
free like whoa that's pretty good
walking is a lot easier now so so we've
experienced this at the bottom and we
actually do experience that same thing
like I said when you use me even
centrally you also feel the same way
about it it's like I'm not really afraid
I'm going to go look in there and jar
XYZ one two three four is going to be
different tomorrow or missing not really
worried about things those things
because they have these rules that play
the game I've been describing so far
which is name should be enduring
in their semantics and you should be a
creating immutable stuff but in the
middle we're messing this up big time
right the way we do artifacts the way we
do namespaces the way we just trash
function signatures is a complete mess
so this is not a surprise at this point
in the talk is semantic versioning
broken totally yes broken bad idea we
should abandon it as soon as possible
right because it is fundamentally in the
in the biggest semantic it has right not
the small ones which are like four is
bigger than three
right in the biggest Symantec has the
semantics about major version change
it's a recipe for how to break software
that's what it is
that's what semantic versioning is like
here's how you break software here's how
you screw up your users here's how you
make like life difficult for people
here's how you undermine software
development and you know and but it's a
standard and it has like you know it has
a web page and everything I'm not
actually you know advocating for
something particular said except to say
that it doesn't matter a whole lot I
mean as long as you have something that
still has the properties the for is
bigger than three you know some sort of
sequentiality to it you have a lot of
options here one of the problems with
versions even if you get rid of the
major version this minor version thing
is that it's it's completely self
relative right 1.2 is bigger than 1.3
but I have these six libraries this is
of these three is 11 years old and the
other one was released yesterday can you
tell which one no these numbers they
don't they don't relate to each other
now that's not saying you could take
this chronological versioning and do
something deterministic with it because
you don't know what people saw right but
you could use Lamport lock like logic to
know what they could not have seen which
is not nothing but you don't have that
otherwise so if your artifact name is a
stable thing a stable a thing as maven
central you have a lot more flexibility
about this you could do something like
this it would convey more information
that then 4.3 does and have some sort of
possibilities for relativism
what about git
so this is another thing I mean
obviously these approaches predate get
everything we're doing about jars and
maven and stuff is really pre good but
git has these great properties is
definitely Cole aligned with a lot of
what I'm saying right it's immutable its
truth of code it really is about this
source code as opposed to stuff you just
made up about it later right 4.3 what I
mean what does it even mean to say this
is 4.3 oh that's good I mean it doesn't
mean anything it really does not mean
anything so the truth is always the code
right now it's quite widely adopted it
has a nice property being able to do
content-based addressing like I said
it's pretty much ignored by the systems
it's not their fault right it's just
that they existed before it does it does
have some challenges I mean I think this
should participate right I started this
talk by saying the truth is actually the
code dependencies and get you know is
where the code is being managed but the
way get talks about stuff is via Shaw's
and people don't like Shaw's they like
the characteristics of it in terms of
being you know a universal unforgeable
key but it doesn't convey anything about
order unless you have the rest of the
repo it doesn't imply anything about
causality I mean four is greater than 3
at least says that it came after and
those readability issues but I you know
I think that there's a way to integrate
this stuff and I think it would be
driven from the bottom back up to make a
solution so
now this is not like me preaching to you
or like I think we all could do better
with us I mean closure doesn't have a
perfect track record in this area but
the most important thing is that you
know we're not going to be able to you
know tack ourselves out of this right
what did I say about maven and it's
actually not broken right what's broken
is that what we're putting into it is
broken for that to be different we need
to not put broken stuff in there and
that's a social thing that's about
considering other people one of the
things I think that makes this
challenging is is open source right
because when we work in a local team or
whatever in your team it might be a
distributed team but when you work in
your team you have a small set of people
and you have stand-ups and you're
working on private stuff that doesn't
get published and no one's consuming
except yourselves you have everybody in
on the call and we say you know what I
think we did this wrong we really do
need to we need wheat and corn to do
this job all right well we got to change
all of our calls to pass corn everybody
good on that yeah Sally when can you
have your wisdom Tuesday I'll have mine
done by Friday all right by next Monday
we'll all be passing wheat and corn
everybody okay yeah yeah yeah yeah great
have a good day
stand up is over now we move to the
internet and we have slack and it feels
like that right we're hanging out or
friends are there a bunch of people that
work in this library are there we're
like ah you know what this library it's
just not good we're a passing wheat and
we need wheat and corn what do you think
oh yeah
I think so too everybody agree on slack
that day agrees
we should be passed in corn all right
good I'm gonna go do it you know I'm
just gonna do it
you know boom get commit github artifact
its enclosure ours you know I talked to
everybody on slack right it feels it
does feel like this like it's the same
because it's what we want I mean so we
would want open-source to be sort of
like the team is now you know everybody
but there's two things maybe everybody
who actually is an author of that
library was in slack right but it's
different my on stand up everyone who
was an author was on stand up and
everyone who was impacted was on stand
up on slack maybe everyone who was an
author was on slack everyone who was
impacted who knows who they are
who knows who all their users of their
libraries are unless it's nobody then
you don't know right so the user base is
open and it's unknown you have to you
have to be caring about these people
that you don't know I know in this
political climate it just seems like
something wild to say but you actually
do you have to care about these people
that you don't know and in software we
need to do the same thing and so open
source development is not the same slack
is not stand up so how do we code for
growth right Alex Miller is talked about
spec a bunch and so has stew and the
number one question they get about spec
is why don't you let me say disallow any
other keys and maps I'm angry about this
I can't check for correctness without
this thing right it is the number one
beef and we saw this beautiful talk by
Paula about logic this morning guess
what most logic systems don't have in
fact I don't know of any logic systems
that do have it
they don't have something that says and
nothing else will ever be true
and the reason why they don't have it is
because then you like you could almost
do no good logic with that system and
you could never ever know or calculate
anything you didn't know on the very
first day right so open specs and open
data formats which we like right we use
maps we use them all the time
in general we should be writing code
that's like doesn't care if those keys
in the map that we don't we don't care
about but it's like a critical thing
about spec spec is about what you could
do but it's not about what you can't do
because tomorrow maybe I could turn weed
into cows you know I don't know
I want to retain the flexibility to be
able to do that especially if I can
figure out how to do that
might be a cool thing so so you can't
let you know you're checking problem du
jour dominate your specs that's not what
specs before they're about what people
can do you could make something with
spec that could do that extra thing
don't put it in your specs that's not
your public thing you want to add
another layer respect that they like
shuts down stuff or run an additional
check to help people you know detect
errors or something like that that's
fine but don't put it in your primary
public spec your primary public specs
you re nted towards growth because
otherwise you're going to have nowhere
to go because what happens if I let you
prohibit things I promise you this is
what it's going to happen and believe me
every engagement we've had where people
said I really want to say you can click
two days later right their world broke
because they had nowhere to go right if
you say you can't do X it means you can
never do X and if you're going to try to
like make it okay to do X later then you
need a new name but now we did the
opposite of what I was saying before
right when I said before is if you're
going to break somebody use a new name
now we're saying if you want to grow use
a new name that's awful right because
that's going to cause your thing to
change the key that was in your map
you're spec to change the spec of the
thing that included you to change the
speculative thing that included that to
change spec is designed so that that
doesn't happen that as long as you make
growing changes you do not need to
cascade up spec is not like semantic
versioning that way but if you do this
you will turn that completely upside
down you will have this problem so this
is why you can't I don't have a shorter
way to do that but that's what that's
why it's this way okay the other thing
you have to do if you want to code for
growth is you always have to presume
people might hand you stuff that you
don't know about that's just got to be
okay although it's a coding discipline
to deal with that a lot of people have
like a just take everything that's in
the map and put it on the screen you
know maybe you should still like keys
right because if you just throw
everything on the screen and they just
give you their you know social security
number because they're there they're
already anticipating you know API to
know which grows in that way that that's
not good
so you have to either ignore it I have a
policy for or something like that but
you should be okay with it
they should not be disallowing this
stuff you can make checkers that run
occasionally to do whatever but as a as
a specification this has to be okay all
right so what about iterative
development right this all sounds like I
got to get it right the first time
right and that's not the case right
you're going to have a place where
you're just trying to figure it out you
get off the hammock I hope you went on
the hammock a little bit you came in you
start typing you know you push something
and you look at it and people kick her
in this like uh you know I tried it it's
not that great that's fine you just need
to be clear that you're there you're in
that mode and people should expect to
have to move along if they're want to
use your alpha they want to be on your
standup they want to be in that circle
but I think what we need is something
more fine grain than artifact releases
to be a tool for publishing actually
calling an entire API and alpha is
somewhat of a problem because this
like then you need this big moment to
get out of that so I think that's an
area where we could we can do something
more specific but that's not to say that
you know just leave your thing
Oh dot oo or dot you know 967
you know at a certain point you're going
to have users and what whether you
change it to 1.0 or not they're going to
be depending on your stuff but I do
think we need to be clearer about like
where your promises lie what did you
actually promise and you know yes you
discovered the fact that if you give me
a ruby i'll give you you know a magical
sword but like I never told you I would
do that why don't I go this far yeah
okay okay so so now we've talked through
we start with code we get two artifacts
there's this magical jump there but this
is other problem which I talked about
when you were building your library
right which is I don't care what you
said in your palm for your library that
does not mean that you're going to get
what you said the very first slide right
one library wanted X you know why 2.1
and another library wanted y 2.4 Lily
both can't get what they want and your
app needs to use both of them so there's
no truth in this transitive dependency
tree it's all suggestive you know I
would like this I would like that you
know it's like a Christmas list Santa
saying you know all right maybe but you
know not everyone's going to get the
train set so the truth is the runtime
classpath you know if you if you're set
aside you know tricky class order stuff
somebody has to make that class path
they will maybe take as input I mean
probably will take as input the
dependency tree they find from maven but
then they're going to have to resolve
things maybe human being is going to get
involved and say you know I know these
two things don't work but it's quite
possible that your library is going to
run against the set of components
has never ever run against right so you
can't say well I built this thing and it
works with 2.1 I don't care I need to
run it with 2.4 because it's running in
a context right that's the thing about
contexts is that you're not guaranteed
your context you get put in a different
context that's what context means so
this has an impact on testing right we
think we tested oh you know whatever you
know reproducible development
reproducible builds now a lot of times
the things that you depend on it doesn't
impact the bytes of your build at all
you're just getting some testing you
know with this library today but it's an
independent thing so you can't test
against an open set of consumers and you
can't test against changes to your
downstream dependencies all the time
which means that the actual testing you
do of your artifact at release time is
limited it should be about you know does
my thing do what it says you know do my
own tests succeed but it's not really
communicating a lot about the
dependencies because they're going to
change but I do think that we need a
higher level way to talk about artifacts
sets that's independent of this tree
right emitted lis as an application I
don't want to have to write an explicit
file with every jar that is the
flattening of the transitive tree but so
I mean how many people have ever had to
exclude or put in an explicit version of
a librarian yeah
and was that fun no but it should be
something that's more practical we
should be able to have tools that start
with the code and say you know what you
don't even need libraries X and Z at all
I'm just not going to include them and
your life is simpler right we should
have things that say we're rolling this
stuff up now if we if we were doing what
I said about names being enduring that
tool would have a lot more leeway and
what it could do it could just say I'm
going to use the latest of everything
and it could know latest without you
telling it as a side effect of updating
your depths and updating your version
all right
a hush comes over the room I mean this
is just
I had a template for the talk and said
insert joke here so what about web
services it's the same thing right so
people are like oh you know jars and
you'll man your Lego you're old we do
everything with Web Services now I don't
care about jars I don't have jar
versioning I do web services I just
talked to services right it's the same
thing it's the same thing it's the same
problems it's the same mistakes
everything is the same
how many people have versioned web
services you have major versions woohoo
and it's no better right versioning is
still not an answer and it's still the
same mistake how many people version
their web service when they change the
arguments to a function you do it I mean
it's okay you do it right so it's what
it's what industry practices people are
doing this right but that's that's a
level that's a level violation right if
you have an operation in your service
and you modify what it does it's a you
know it's putting on a hat your web
service is not a different service your
service provides a set of operations a
web service is a collection of
operations the end it's a collection
that's the end of that level the two
things you can do to a web service you
can add operations and get rid of
operations right then you can mess
around with operations and you can look
at them just like we looked at functions
what do they require what do they
provide is there a way to grow web
service operations yes especially if you
take these approaches about openness and
open specifications and open data
formats right is there a way to provide
more back from a web service and grow
that way totally yes as long as you have
expressed to your consumers I'm going to
give you at least this but I may give
you more right then we can grow together
right similarly you can break them in
the same ways requiring more providing
less
right and when you think you want to do
that well think twice because what
happens if you instead of saying I'm
going to break foo you make foo - right
well if you were going to break foo what
would you have to do right what happens
today you break foo you say we have
version two of our API yet to tell
everybody in their mother
version 2 of the API is coming Tuesday
switch here talk to this new endpoint
blah blah blah change your world right
there's no getting around that now
happens if you just put through - next -
foo you can still tell people they could
say I'm in Bermuda this week but next
week I will try foo - that sounds
awesome but right now my web service is
going to keep working because it calls
foo and you didn't take it away from me
while I was on vacation right this this
thing accretion solves the problem
exactly the same way right so what we
need to do is bring functional
programming to the library ecosystem
that's it we need to take this thing we
need to make it a good sandwich that you
know the top and the bottom and the
middle are all good right right now we
do update in place we excuse it with
this versioning thing which is just not
good right dependency hell is not a
different thing than mutability hell
it's the same thing it is mutability how
it's just at the scale right it makes
programming fragile but the worst thing
is this it makes libraries less useful
how many people are reluctant to take on
dependencies yeah I am right and it's
not just because like they bulk up my
thing it's because I'm afraid I'm afraid
of other people
but I don't want to be afraid of other
people and I don't think we also be
afraid of other people and this is the
thing that's really sad about this is
that you made your thing and you open
sourced it you got a slack and you were
feeling all really good about things but
people don't trust you and it's not
necessarily because you did anything
wrong it's just because they've seen
this happen right and like I said before
it's sort of a social thing now how many
people saying no right this all sounds
fine but like it's easy for me to make a
little piece of data immutable it's easy
for me to know the 42 can't change to 43
but at the scale you know I just have
new requirements all the time
you can't possibly make a big thing that
doesn't change this is just not true
look at these things and when try to
call something from the UNIX that was
there in 1970 something it's still there
it still works the same way every trying
to run an old Java program still works
right people still using same old HTML
still working right and I think closure
core also has had this you know approach
I don't think we've done it perfectly
but it's a value prop so when I keep
saying no and when stuffs just stays
there that you think oh get rid of this
I hate this function but this is why
it's still there because I don't want to
do that people and and I think that
whatever makes things successful is
somewhat unknown but I know that I
really believe that compatibility is a
prerequisite to being successful you
cannot ignore this and have something
that that's going to endure the people
are going to value and if you want
people to value the stuff that you write
you need to consider this so what would
happen if we never broke anything
names would be adorable enduringly
mutable a meaningful right maven central
I know what it does for me and will
always do that right this compatibility
checking I was talking about it would be
possible and we would also be able to
sort of just move to the latest and let
a testing thing that's independent of
any of the authors go and figure out
right thing figure out who needed what
when what the times were here's a set
that works because it's not going to
have to be afraid of these breakages
right we could look into fine grain
dependencies right which is something I
think is particularly interesting and
I'll talk about it in another slide we
could use the latest with impunity we do
that with maven central right we're not
like oh man I need to get at maven
central from three weeks ago we don't
ever say that right and the other thing
that's super critical to software dome
is that we can compose with impunity
right when we when we take two things
and then the third thing needs one of
the other things and we don't really
know we can put them together we can't
we're missing composition which is
something you know we value as
functional programmers so I think
there's a bunch of open challenges here
one is that the some changes we can't
see I talked earlier about arguments and
returns right there's not harder to see
then you know the presence of a function
or the dependency on a function
collections are straightforward but when
we start using spec more it will help
here because we'll be able to see in a
growing change to a spec that something
changed right the calls don't
necessarily look different yeah or in a
way that's machine detectable but the
spec will have change in a compatible
way and kept the same name well we could
see that happening right the spec
compatibility is a little bit tricky
right because compatibility somewhat
difference depending on whether or not
you're supplying you're providing
something or requiring it because you
can make a spec bigger or smaller and we
know in one case it's breaking and in
other case it's not so this
directionality is something that I want
to build into spec being able to
determine the difference this spec in
this context is the providing context
versus a requiring context I mentioned
repoed artifact two namespaces it would
be great to fix that it would be great
to have global registries of given this
namespace here's a repo here's the
artifact and then we can work from the
bottom up as opposed to I talked to Fred
and he said
use this jar and then you know I I found
that you know and Cantor was in it
that's cool yeah we shouldn't it should
work the other way and another big
problem is just it we just have tooling
that says do this when we have culture
that says do this this we solved this
problem we have major versions for this
alright so closure can help we have spec
I think that will lead us to flexible
DEP awareness right as opposed to this
fragile brittle thing which is talking
about too much we saw it was already
broken even at the first example maybe
we can do something explicit about code
two artifacts which I was just saying I
also mentioned before maybe we could be
you know public is not really that great
because a consumer of your alpha needs
access to something so you really need
to say something else when you say I'm
publishing this I'm making a commitment
now and similarly you might want to say
it's deprecated doesn't mean I'm going
to take it away it just means hey look
over here this food - it's better it's
twice as fast and you know it makes cows
the other thing that's going to come out
of this is testing based on fine-grained
EPS I don't want to steal Alex's thunder
but this is something that we're already
working on right because it's necessary
for generative testing right right now
you press save in your editor and like
all your tests run because you're
testing pretty useless you wrote them
yourself and they don't test anything
right but generative tests are useful
and but they're they take a long time
but the thing is who why should we ever
test this function more than once if we
didn't change this function should we
test it again and again and again and
again should I test it in you tested and
somebody else doesn't somebody else test
it this is pointless we should have
shah's for code and say I tested this
shot it's done and I tested the shot in
this context with this other function we
know what the fine-grained depths are
this is something that you could have
and then yeah you could proceed but only
the stuff that actually is affected by
what you did would get this you know
admittedly more expensive generative
testing all right I know everyone see
and I certainly do so what I'm going to
say is you should value exchange over
change
right writing libraries for other people
to use is about exchanging right if you
need to change it you need to be
considerate because the primary thing is
exchange not change right and there's
two really good ways to do this one is
to grow your software just grow it right
the other is to turn what would have
been breaking into a chr?tien right in
other words if you're going to have a
variant you know give birth to a variant
don't muck with the thing right think of
the children think of the consumers and
that's not to say the consumers are kids
I mean I think to sort of think of the
children is less about children than it
is about like the future right think
about the future of your software do you
ever want to be able to change it and
fix it and make it better and have
people rely on it and like you then you
need to do this you need to move forward
without sort of trashing stuff behind
you and like I said I think we all could
do better with this and I'm certainly
hopeful that we'll start with some of
the contribs and apply some of these new
things but I would like closure to lead
in this area I think what I've described
is not unique to closure it's sort of
the industry standard and it's not great
so why don't we be the first community
to make it great that's it
[Applause]
you
[Applause]


